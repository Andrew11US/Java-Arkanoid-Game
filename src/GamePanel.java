import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;

public class GamePanel extends JPanel implements KeyListener, Paintable, Runnable {
    private Ball ball;
    private Paddle paddle;
    private ArrayList<Brick> bricks = new ArrayList<>();
    private Image image;
    private Thread thread;
    private boolean pause = true;
    private int bricksCount = 0;
    public int lives = 3;
    public int score = 0;
    private boolean isRunning = true;

    public GamePanel() {
        resetScene(true);
        addKeyListener(this);
        setFocusable(true);
//        run();
    }

    @Override
    public void paint(Graphics g) {
        this.ball.paint(g);
        this.paddle.paint(g);
        bricks.forEach(block -> block.paint(g));
        g.drawImage(image, 0, 0, this);
    }

    private void resetScene(boolean isNew) {
        ball = new Ball();
        paddle = new Paddle();

//        ball.speed = 1;
//        lives = 3;
//        if (!bricks.isEmpty()) bricks.clear();

        // TODO: Refactor to add more lives on level passed
        if (isNew) {
            score = 0;
            bricksCount = 0;
            //*
            for(int i = 1; i < 7; ++i) {
                for(int j = 1; j < 5; ++j) {
                    bricks.add(new Brick(i*60,j*40));
                    bricksCount++;
                }
            }
            /*/
            for(int i = 2; i < 3; ++i) {
                for(int j = 2; j < 3; ++j) {
                    bricks.add(new Brick(i*120,j*40));
                    bricksCount++;
                }
            }
            //*/




        } else {
            // Respawn existing bricks
        }


//        pause();

    }

    public void updateView() {

        ball.x += ball.xDirection * ball.speed;
        ball.y += ball.yDirection * ball.speed;

        if(ball.x > (getWidth() - 20) || ball.x < 0) {
            ball.xDirection *= -1;
        }

        if(ball.y < 0 || ball.intersects(paddle)) {
            ball.yDirection *= -1;
        }

        if (ball.y > getHeight()) {
            thread = null;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Loose or game over
            lives -= 1;
            if (lives != 0) {
                resetScene(false);

//                pause();
            } else {
                isRunning = !isRunning;
                System.out.println("Game Over!");
                removeKeyListener(this);
            }

//            pause();
        }

        bricks.forEach(brick -> {
            if (!brick.destroyed && ball.intersects(brick)) {
                brick.destroyed = true;
                ball.yDirection *= -1;
                ball.xDirection *= -1;
                score++;
                System.out.println(score);

//                if (score == bricksCount) {
//                    System.out.println("Level passed!");
//                    try {
//                        Thread.sleep(1000);
//                        thread.interrupt();
//                    } catch (InterruptedException e) {
//                        e.printStackTrace();
//                    }
//                    this.thread.interrupt();
//                    this.thread = null;
//                    this.run();
//                    this.resetScene();
//                }
            }
        });

        if (score == bricksCount) {
            System.out.println("Level passed!");

            if (isRunning) {
                thread = null;


                isRunning = !isRunning;

                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                resetScene(true);
                run();
                isRunning = !isRunning;
            }
        }
        repaint();
    }

    public void pause() {
        pause = !pause;

        if (pause) {
            ball.speed = 0;
        } else {
            ball.speed = 1;
        }
    }

    @Override
    public void run() {
//        resetScene();
//        pause();
        thread = new Thread(() -> {
            while (isRunning) {
                updateView();
                try {
                    Thread.sleep(10);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
        });
        thread.start();
    }



    // MARK: Autogenerated methods for KeyListener

    @Override
    public void keyTyped(KeyEvent e) {

    }


    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_SPACE && thread == null) {
            System.out.println("Space");
            pause();
            thread = new Thread(() -> {
                while (isRunning) {
                    updateView();
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
                }
            });
            thread.start();
        }

        if (e.getKeyCode() == KeyEvent.VK_RIGHT && paddle.x < (getWidth() - paddle.width)) {
            if (!pause) {
                paddle.x += 15;
                updateView();
            }
        }

        if (e.getKeyCode() == KeyEvent.VK_LEFT && paddle.x > 0) {
            if (!pause) {
                paddle.x -= 15;
                updateView();
            }
        }

        if (e.getKeyCode() == KeyEvent.VK_P) {
//            System.out.println("P");
            pause();
        }
    }




    @Override
    public void keyReleased(KeyEvent e) {

    }
}
