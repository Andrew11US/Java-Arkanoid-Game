import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.ArrayList;

public class GamePanel extends JPanel implements KeyListener, Paintable, Runnable {
    private Ball ball;
    private Paddle paddle;
    private ArrayList<Brick> bricks = new ArrayList<>();
    private Image image;
    private Thread thread;
    private boolean isPaused = false; // Pauses the game, changing the ball.speed to 0, (recoverable action)
    private boolean isRunning = true; // Stops the game breaking while loop, doesn't recover running if changed oposite!
    private int bricksCount = 0;
    public int level = 1;
    public int lives = 3;
    public int score = 0;



    public GamePanel() {
//        resetScene(true);
        newGame();
        addKeyListener(this);
        setFocusable(true);
//        run();
    }

    @Override
    public void paint(Graphics g) {
        this.ball.paint(g);
        this.paddle.paint(g);
        bricks.forEach(block -> block.paint(g));
        g.drawImage(image, 0, 0, this);
    }

    private void newGame() {
        ball = new Ball();
        paddle = new Paddle();

        for(int i = 1; i < 7; ++i) {
            for(int j = 1; j < 5; ++j) {
                bricks.add(new Brick(i*60,j*40));
                bricksCount++;
            }
        }
    }

    private void resetScene(boolean isNew) {
        ball = new Ball();
        paddle = new Paddle();

//        lives = 3;
//        if (!bricks.isEmpty()) bricks.clear();

        if (isNew) {
            score = 0;
            bricksCount = 0;
            //*
            for(int i = 1; i < 7; ++i) {
                for(int j = 1; j < 5; ++j) {
                    bricks.add(new Brick(i*60,j*40));
                    bricksCount++;
                }
            }
            /*/
            for(int i = 2; i < 3; ++i) {
                for(int j = 2; j < 3; ++j) {
                    bricks.add(new Brick(i*120,j*40));
                    bricksCount++;
                }
            }
            //*/




        } else {
            // Respawn existing bricks
        }


//        pause();

    }

    public void updateView() {

        ball.x += ball.xDirection * ball.speed;
        ball.y += ball.yDirection * ball.speed;

        if(ball.x > (getWidth() - 20) || ball.x < 0) {
            ball.xDirection *= -1;
        }

        if(ball.y < 0 || ball.intersects(paddle)) {
            ball.yDirection *= -1;
        }

        if (ball.y > getHeight()) {
            thread = null;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // Loose or game over
            lives -= 3;
            if (lives != 0) {
                resetScene(false);

//                pause();
            } else {
                isRunning = !isRunning;
                System.out.println("Game Over!");
                removeKeyListener(this);
                Game game = Game.getInstance();
                game.menuFrame.setVisible(true);
                game.frame.setVisible(false);
                game.frame.remove(this);
            }

//            pause();
        }

        bricks.forEach(brick -> {
            if (!brick.destroyed && ball.intersects(brick)) {
                brick.destroyed = true;
                ball.yDirection *= -1;
                ball.xDirection *= -1;
                score++;
                System.out.println(score);
            }
        });

        if (score == bricksCount) {
            System.out.println("Level passed!");
            level += 1;
            if (lives != 3) lives+=1;
            System.out.println("Level: " + level);

            if (isRunning) {
                thread = null;


                isRunning = !isRunning;

                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                resetScene(true);
                run();
                isRunning = !isRunning;
            }
        }
        repaint();
    }

    public void pause() {
        isPaused = !isPaused;

        if (isPaused) {
            ball.speed = 0;
        } else {
            ball.speed = 1;
        }
    }

    @Override
    public void run() {
//        resetScene();
//        pause();
        thread = new Thread(() -> {
            while (isRunning) {
                updateView();
                try {
                    Thread.sleep(10);
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
            }
        });
        thread.start();
    }



    // MARK: Autogenerated methods for KeyListener

    @Override
    public void keyTyped(KeyEvent e) {

    }


    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_SPACE && thread == null) {
            System.out.println("Space");
//            pause();
            thread = new Thread(() -> {
                while (isRunning) {
                    updateView();
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException ex) {
                        ex.printStackTrace();
                    }
                }
            });
            thread.start();
        }

        if (e.getKeyCode() == KeyEvent.VK_RIGHT && paddle.x < (getWidth() - paddle.width)) {
            if (!isPaused) {
                paddle.x += 15;
                updateView();
            }
        }

        if (e.getKeyCode() == KeyEvent.VK_LEFT && paddle.x > 0) {
            if (!isPaused) {
                paddle.x -= 15;
                updateView();
            }
        }

        if (e.getKeyCode() == KeyEvent.VK_P) {
            pause();
        }
    }




    @Override
    public void keyReleased(KeyEvent e) {

    }
}
